import json
from sys import argv
from pathlib import Path
from typing import Any, Dict, List, cast
from .synthesis.inference import (
    AbstractValue,
    infer_leaf_types,
    leaf_to_sink_paths,
    merge_objs,
    reconstruct_inputs,
    generate_operation_tree,
    insert_solved_fields,
    TypeSet,
)
from .synthesis.parser import PTreeParser
from .synthesis.utils import print_obj, print_str
from .synthesis.smt_generator import SMTGenerator


class Args(object):
    def __init__(self, args: List[str]):
        self._args: Dict[str, Any] = self.parse(args)

    def parse(self, args: List[str]) -> Dict[str, Any]:
        parsed_args: Dict[str, Any] = {}
        for arg in args:
            if "--" in arg:
                arg = arg.strip()
                arg = arg.replace("--", "")
                if "=" in arg:
                    parts = arg.split("=")
                    parsed_args[parts[0]] = parts[1]
                else:
                    parsed_args[arg] = None
        return parsed_args

    def has(self, name: str) -> bool:
        if name in self._args:
            return True
        return False

    def get(self, name: str) -> Any:
        if self.has(name):
            return self._args[name]
        raise Exception(f"Argument not present: {name}")

    @property
    def len(self) -> int:
        return len(self._args)


def main(args: Args):
    assert (
        args.len > 0
    ), """Expected args:
    --prov=<path>   Path to provenance graph to parse
    --honeyobjects  (Optional) Enable if using honeyobjects in analysis (default: False)
    --debug         (Optional) Enable debug mode (default: False)
    --concretize    (Optional) Enable concretization mode (default: False)
    --solving-time  (Optional) Time in seconds for Z3 to solve (default: 60)
    --ignore-errors (Optional) Ignore errors in SMT generation (default: False)
    --allow-unsound (Optional) Allow unsoundness in SMT generation (default: False)
    --use-inference (Optional) Use inference in SMT generation (default: False)
    --use-enumerator (Optional) Use enumerator in SMT generation (default: False
    --use-enumerator-templates (Optional) Use templates from the enumerator (default: False)
    --use-polyglot-aci-payload (Optional) Use polyglot ACI payload (default: False)
    --use-polyglot-ace-payload (Optional) Use polyglot ACE payload (default: False)
    --only-string-datatype (Optional) Only use string datatype (default: False)
    """
    provenance_path = Path(args.get("prov"))
    using_honeyobjects = False
    if args.has("honeyobjects"):
        using_honeyobjects = True
    debug_mode = False
    if args.has("debug"):
        debug_mode = True
    concretize_mode = False
    if args.has("concretize"):
        concretize_mode = True
    solving_time = 60
    if args.has("solving-time"):
        solving_time = int(args.get("solving-time"))
    ignore_errors = False
    if args.has("ignore-errors"):
        ignore_errors = True
    allow_unsound = False
    if args.has("allow-unsound"):
        allow_unsound = True
    use_inference = False
    if args.has("use-inference"):
        use_inference = True
    use_enumerator = False
    if args.has("use-enumerator"):
        use_enumerator = True
    use_enumerator_templates = False
    if args.has("use-enumerator-templates"):
        use_enumerator_templates = True
    use_polyglot_aci_payload = False
    if args.has("use-polyglot-aci-payload"):
        use_polyglot_aci_payload = True
    use_polyglot_ace_payload = False
    if args.has("use-polyglot-ace-payload"):
        use_polyglot_ace_payload = True
    only_string_datatype = False
    if args.has("only-string-datatype"):
        only_string_datatype = True
    with open(provenance_path, "r", encoding="utf-8") as prov_fp:
        provenance_data = json.load(prov_fp)
    print_str(
        "",
        f"Parsing: {provenance_path} | honeyobjects: {using_honeyobjects}",
        should_print=debug_mode,
    )
    ptree = PTreeParser().parse(provenance_data)
    if use_inference:
        print_str("PTree", ptree.serialize_children(verbose=True), should_print=debug_mode)
        leaf_paths = leaf_to_sink_paths(ptree)
        print_obj("Leaf Paths", leaf_paths, should_print=debug_mode)
        leaf_types = infer_leaf_types(leaf_paths, using_honeyobjects)
        print_obj("Leaf Types", leaf_types, should_print=debug_mode)
        leaf_objs = reconstruct_inputs(leaf_types)
        print_obj("Leaf Objects", leaf_objs, should_print=debug_mode)
        merged = merge_objs(cast(List[AbstractValue], leaf_objs.values()))
    else:
        merged = AbstractValue(
            id="root",
            type_set=TypeSet(["Bot"]),
            structure={},
            constraints=[],
            concrete=None,
        )
    if debug_mode:
        print_obj("Merged Object", merged, should_print=debug_mode)
        reified = merged.reify()
        print_obj("Reified Merged Object", reified, should_print=debug_mode)
        print_obj(
            "Concretized Merged Object", reified.concretize(), should_print=debug_mode
        )
    optree = generate_operation_tree(ptree, merged)[0]
    print_obj("Optree", optree, should_print=debug_mode)
    gen = SMTGenerator(
        optree,
        allow_unsound=allow_unsound,
        use_enumerator=use_enumerator,
        use_enumerator_templates=use_enumerator_templates,
        use_polyglot_aci_payload=use_polyglot_aci_payload,
        use_polyglot_ace_payload=use_polyglot_ace_payload,
        only_string_datatype=only_string_datatype,
    )
    smt_statement = None
    try:
        smt_statement = gen.generate()
        print_str("SMT Statement", smt_statement, should_print=debug_mode)
    except Exception as exn:
        print_str(
            "SMT Statement", f"Failed to generate: {exn}", should_print=debug_mode
        )
        if not ignore_errors:
            raise exn
    solution = None
    if smt_statement is not None:
        solution, solving_time = gen.solve(solving_time)
        print_str("SMT Solution", solution, should_print=debug_mode)
    final_abstract_value = merged
    if solution and solution not in ("unsat", "unknown"):
        final_abstract_value = insert_solved_fields(merged, solution)
        print_obj(
            "Solver-Concretized Abstract Value",
            final_abstract_value,
            should_print=debug_mode,
        )
        print_obj(
            "Refied Solver-Concretized Abstract Value",
            final_abstract_value.reify(),
            should_print=debug_mode,
        )
    ret = {
        "smt_statement": smt_statement,
        "smt_solution": solution,
        "solving_time_sec": solving_time,
        "abstract_value": final_abstract_value.to_json(),
        "concretized": final_abstract_value.reify().concretize()
        if concretize_mode
        else None,
    }
    print(json.dumps(ret, indent=4))


if __name__ == "__main__":
    main(Args(argv[1:]))

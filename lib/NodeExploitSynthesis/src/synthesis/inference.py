from functools import partial
import json
from pathlib import Path
from random import randint, seed
from typing import Any, Callable, List, Dict, Set, Optional, TypeVar, TypedDict, cast
from .parser import (
    PTreeAndDepth,
    PTreeNode,
    BuiltinOperationType,
    PyJsType,
    SinkOperationType,
    FieldOperationType,
    OtherOperationType,
)


# Set fixed seed for random generation
seed(0)


T = TypeVar("T")


def random_choice(l: List[T]) -> T:
    return l[randint(0, len(l) - 1)]


class TypeLattice(object):
    def __init__(self, lattice_path: Path):
        with open(lattice_path, "r") as lattice_f:
            self.transitions = json.load(lattice_f)

    def transition(self, state: str, edge: str) -> str:
        assert state in self.transitions, f"Unhandled state: {state}"
        if edge not in self.transitions[state] or edge == "!":
            # This is equivalent to a "*" edge
            return state
        return self.transitions[state][edge]


LeafPaths = Dict[int, List[PTreeNode]]


def leaf_to_sink_paths(ptree: PTreeNode) -> LeafPaths:
    leaf_nodes = ptree.get_nodes(filter=lambda x: len(x["node"].parents) == 0)

    def get_just_nodes(nodes: List[PTreeNode], data: PTreeAndDepth):
        nodes.append(data["node"])

    leaf_paths: LeafPaths = {}
    for i, node in enumerate(leaf_nodes):
        nodes: List[PTreeNode] = []
        fn = cast(Callable[[PTreeAndDepth], None], partial(get_just_nodes, nodes))
        node.map(fn, for_parents=False)
        leaf_paths[i] = nodes
    return leaf_paths


class TypeSet(object):
    def __init__(self, types: List[str]):
        self._types = set(types)

    @property
    def types(self) -> Set[str]:
        return self._types

    @property
    def length(self):
        return len(self.types)

    def as_list(self) -> List[str]:
        return list(self.types)

    @staticmethod
    def from_str(s: str) -> "TypeSet":
        return TypeSet([v for v in s.split("|") if v != ""])

    def __repr__(self) -> str:
        return "|".join(self.types)

    def __eq__(self, other: object):
        if type(other) == TypeSet:
            return self.types == other.types
        return False

    def union(self, other: "TypeSet") -> "TypeSet":
        return TypeSet(list(self.types.union(other.types)))

    def is_subset_of(self, other: "TypeSet") -> bool:
        return self.types.issubset(other.types)


class InferredTypeData(object):
    def __init__(
        self,
        type_set: TypeSet,
        annotation: Optional[str],
        ptree_node: PTreeNode,
    ):
        self._type_set = type_set
        self._annotation = annotation
        self._ptree_node = ptree_node

    @property
    def type_set(self):
        return self._type_set

    @property
    def annotation(self):
        return self._annotation

    @property
    def value_py_type(self):
        return type(self._ptree_node.value)

    @property
    def id(self):
        return self._ptree_node.id

    @property
    def friendly_id(self):
        return self._ptree_node.friendly_id

    @property
    def operation(self):
        return self._ptree_node.operation

    @property
    def operation_type(self):
        return self._ptree_node.operation_type

    def get_args(self):
        args: List[PyJsType] = []

        def add_arg(other: PTreeNode):
            if self.operation == other.operation and other.value is not None:
                args.append(other.value)

        self._ptree_node.map(
            lambda ptreedepth: add_arg(ptreedepth["node"])
            if ptreedepth["depth"] == 1
            else None
        )
        return args

    def __repr__(self):
        return f"({self.friendly_id}: {self.type_set}, {self.annotation}, {self.operation}, {self.operation_type})"


LeafTypePath = List[InferredTypeData]
LeafTypes = Dict[int, LeafTypePath]


def python_to_js_type(py_type: type) -> str:
    if py_type == dict:
        return "Object"
    elif py_type == str:
        return "String"
    elif py_type == int:
        return "Number"
    elif py_type == float:
        return "Number"
    elif py_type == bool:
        return "Boolean"
    elif py_type == list:
        return "Array"
    else:
        raise Exception(f"Unhandled type for conversion: {py_type}")


def infer_leaf_types(
    leaf_paths: LeafPaths, using_honeyobjects: bool = False
) -> LeafTypes:
    coercive_operations = ["concat"]
    lattice_path = Path(__file__).parent / "operation_types" / "lattice.json"
    assert lattice_path.exists(), "Could not find lattice definition"
    tl = TypeLattice(lattice_path)
    leaf_types: LeafTypes = {}
    for k, v in leaf_paths.items():
        state = "Bot"
        leaf_types[k] = [
            InferredTypeData(
                TypeSet.from_str(state),
                "Leaf",
                v[0],
            )
        ]
        for node in v[1:]:
            operation_type = node.operation_type
            value = None
            if isinstance(operation_type, BuiltinOperationType):
                if node.operation in coercive_operations:
                    new_state = tl.transition(state, "*")
                else:
                    new_state = tl.transition(state, str(operation_type))
            elif isinstance(operation_type, OtherOperationType):
                if "__jalangi_set_taint__" in node.operation:
                    new_state = state
                    value = "Tainted:" + node.parents[0].id
                else:
                    new_state = tl.transition(state, "*")
            elif isinstance(operation_type, FieldOperationType):
                assert (
                    len(node.parents) > 1 and len(node.parents) <= 3
                ), f"Unhandled length: {len(node.parents)} at node {node.friendly_id}"
                # Determine if the parent is a builtin field
                if isinstance(node.parents[1].operation_type, BuiltinOperationType):
                    new_state = tl.transition(
                        state, str(node.parents[1].operation_type)
                    )
                    value = "BuiltinField:" + str(node.parents[1].value)
                else:
                    if node.parents[1].value:
                        field_name = str(node.parents[1].value)
                    else:
                        # Heuristic for undefined fields
                        # field_name = "0"
                        # Alternative: If the field name is undefined, then
                        # we can't really infer anything about the type
                        continue
                    # node.value is the result of the field access
                    if node.value is not None:
                        new_state = python_to_js_type(type(node.value))
                        if using_honeyobjects and new_state == "Object":
                            new_state = tl.transition(state, "->")
                    else:
                        # Heuristic to better narrow down the type
                        # Note: This may be too conservative; technically
                        # RegExp, Date, Map, Set, WeakMap, WeakSet support
                        # adding properties with arbitrary names
                        if field_name.isnumeric():
                            new_state = "Array|String|Object"
                        else:
                            new_state = "Object"
                    value = "GetField:" + field_name
            elif isinstance(operation_type, SinkOperationType):
                new_state = tl.transition(state, "!")
                value = "End"
            else:
                raise Exception(f"Unexpected operation type: {operation_type}")
            leaf_types[k].append(
                InferredTypeData(
                    TypeSet.from_str(state),
                    value,
                    node,
                )
            )
            if value and "GetField" in value:
                leaf_types[k].append(
                    InferredTypeData(
                        TypeSet.from_str(new_state),
                        "TheField",
                        node,
                    )
                )
                new_state = "Bot"
            state = new_state
    return leaf_types


class AbstractValueJson(TypedDict):
    """
    JSON-serializable AbstractValue
    id: ID of the value
    types: A list of inferred type names for this value
        (type name is one of "String", "Object", "Boolean", "Number", "Array")
    structure: A dictionary of inferred value fields mapping to AbstractValueJson
    constraints: Constraints that apply to the value
    concrete: Optional concrete value of the abstract value from SMT solver
    """

    id: str
    types: List[str]
    structure: Dict[str, "AbstractValueJson"]
    constraints: List[str]
    concrete: Optional[str]


class AbstractValue(object):
    def __init__(
        self,
        id: str,
        type_set: TypeSet,
        structure: Dict[str, "AbstractValue"],
        constraints: List[str] = [],
        concrete: Optional[str] = None,
    ):
        self._id = id
        self._type_set = type_set
        self._structure = structure
        self._constraints = constraints
        self._concrete = concrete

    @property
    def id(self) -> str:
        """
        ID of the value
        """
        return self._id

    @property
    def type_set(self) -> TypeSet:
        return self._type_set

    @property
    def structure(self) -> Dict[str, "AbstractValue"]:
        return self._structure

    @property
    def constraints(self) -> List[str]:
        return self._constraints

    @property
    def concrete(self) -> Optional[str]:
        return self._concrete

    def set_concrete(self, value: Optional[str]):
        self._concrete = value

    def reify(self) -> "AbstractValue":
        new_structure: Dict[str, "AbstractValue"] = {}
        for k, v in self.structure.items():
            new_structure[k] = v.reify()
        # Heuristic to favor reifying to strings when other structure is not present
        if "String" in self.type_set.as_list() and len(self.structure.keys()) == 0:
            new_type_set = TypeSet(["String"])
        # Heuristic to favor reifying to objects
        elif "Object" in self.type_set.as_list() or "Bot" in self.type_set.as_list():
            new_type_set = TypeSet(["Object"])
        # No heuristic; fall back to randomly picking a type
        else:
            new_type_set = TypeSet([random_choice(self.type_set.as_list())])
        return AbstractValue(
            self.id,
            new_type_set,
            new_structure,
            self.constraints,
            self.concrete,
        )

    def replace_non_numeric_keys(self):
        assigned_keys = set(self.structure.keys())
        new_structure = {}
        for k, v in self.structure.items():
            if not k.isnumeric():
                i = 0
                while True:
                    if str(i) not in assigned_keys:
                        break
                    i += 1
                new_structure[str(i)] = v
                continue
            new_structure[k] = v
        self._structure = new_structure

    def concretize(self) -> object:
        assert len(self.type_set.as_list()) == 1, "Reify first"
        this_type = self.type_set.as_list()[0]
        if this_type == "Object" or this_type == "Bot":
            ret_d: Dict[str, object] = {}
            for k, v in self.structure.items():
                ret_d[k] = v.concretize()
            if not ret_d:
                return self.concrete
            return ret_d
        elif this_type == "Array":
            if not all([i.isnumeric() for i in self.structure.keys()]):
                self.replace_non_numeric_keys()
            ret_a: List[object] = []

            if len(self.structure.keys()) == 0:
                array_size = 0
            else:
                array_size = max([int(i) for i in self.structure.keys()])

            ret_a = [""] * (array_size + 1)
            for k, v in self.structure.items():
                ret_a[int(k)] = v.concretize()

            if not ret_a or ('global' not in str(ret_a) and 'success' not in str(ret_a)):
                return self.concrete
            else:
                return ret_a

        elif self.concrete:
            return self.concrete
        elif this_type == "String":
            return ""
        elif this_type == "Boolean":
            return random_choice([True, False])
        elif this_type == "Number":
            return 0
        elif this_type == "Date":
            return "2023-05-02T19:16:41.364Z"
        elif this_type == "Set":
            ret_s: Set[object] = set()
            for _, v in self.structure.items():
                ret_s.add(v.concretize())
            return ret_s
        elif this_type == "WeakSet":
            ret_ws: Set[object] = set()
            for _, v in self.structure.items():
                ret_ws.add(v.concretize())
            return ret_ws
        elif this_type == "Map":
            ret_m: Dict[str, object] = {}
            for k, v in self.structure.items():
                ret_m[k] = v.concretize()
            return ret_m
        elif this_type == "WeakMap":
            ret_wm: Dict[str, object] = {}
            for k, v in self.structure.items():
                ret_wm[k] = v.concretize()
            return ret_wm
        elif this_type == "RegExp":
            return "\\\\g"
        elif this_type == "Error":
            return "Error()"
        else:
            raise Exception(f"Unhandled type concretization: {this_type}")

    def to_json(self) -> AbstractValueJson:
        as_json: AbstractValueJson = {
            "id": self.id,
            "types": self.type_set.as_list(),
            "structure": {},
            "constraints": self.constraints,
            "concrete": self.concrete,
        }
        for k, v in self.structure.items():
            as_json["structure"][k] = v.to_json()
        return as_json

    def __repr__(self):
        return json.dumps(self.to_json(), indent=4)


class AbstractOperation(object):
    def __init__(
        self, operation: str, children: List["AbstractOperation | AbstractValue"]
    ):
        self._operation = operation
        self._children = children

    @property
    def operation(self) -> str:
        return self._operation

    @property
    def children(self) -> List["AbstractOperation | AbstractValue"]:
        return self._children

    def to_json(self) -> object:
        return {
            "operation": self.operation,
            "children": [c.to_json() for c in self.children],
        }


def process_path(path: LeafTypePath) -> AbstractValue:
    current_type = None
    for i, data in enumerate(path):
        if data.annotation and "GetField" in data.annotation:
            field_name = data.annotation.split(":")[1]
            next_value = process_path(path[i + 1 :])
            if data.type_set == TypeSet(["Bot"]):
                # TODO: Should the type set be data.type_set or path[i + 1].type_set?
                return AbstractValue("", data.type_set, {field_name: next_value})
            elif TypeSet(["Object"]).is_subset_of(data.type_set) or TypeSet(
                ["Bot"]
            ).is_subset_of(data.type_set):
                return AbstractValue("", data.type_set, {field_name: next_value})
            elif data.type_set == TypeSet(["Array"]):
                return AbstractValue("", data.type_set, {field_name: next_value})
            elif data.type_set == TypeSet(["String"]):
                return AbstractValue(path[0].id, data.type_set, {})
            elif data.type_set == TypeSet(["Number"]):
                return AbstractValue(path[0].id, data.type_set, {})
            elif data.type_set == TypeSet(["Boolean"]):
                return AbstractValue(path[0].id, data.type_set, {})
            # else:
            #     raise Exception(f"Unhandled inferred type: {data.type_set}")
            # Fall back to just including typeset as is
            else:
                return AbstractValue(path[0].id, data.type_set, {})
        elif isinstance(data.operation_type, BuiltinOperationType):
            if not current_type:
                raise Exception(f"Unhandled structure in path: {path[0]}")
            new_constraints: List[str] = []
            for constraint in current_type.constraints:
                new_constraints.append(constraint)
            if data.operation in ["slice", "substr"]:
                op = data.operation + str(data.get_args())
                new_constraints.append(op)
            current_type = AbstractValue(path[0].id, data.type_set, {}, new_constraints)
        else:
            current_type = AbstractValue(path[0].id, data.type_set, {})
    assert current_type is not None, "Current type was None!"
    return current_type


def tainted_path(path: LeafTypePath) -> bool:
    for data in reversed(path):
        if data.annotation is None:
            continue
        elif "Tainted" in data.annotation:
            return True
    return False


def filter_tainted_paths(leaf_types: LeafTypes) -> LeafTypes:
    new_leaf_types: LeafTypes = {}
    for k, v in leaf_types.items():
        if tainted_path(v):
            new_leaf_types[k] = v
    if len(new_leaf_types) == 0:
        # raise Exception("No tainted paths found")
        # Select the longest path
        selection = max(leaf_types.keys(), key=lambda k: len(leaf_types[k]))
        new_leaf_types[selection] = leaf_types[selection]
    return new_leaf_types


def reconstruct_inputs(leaf_types: LeafTypes) -> Dict[str, AbstractValue]:
    leaf_objs: Dict[str, AbstractValue] = {}
    leaf_types = filter_tainted_paths(leaf_types)
    for _, path in leaf_types.items():
        assert path[0].annotation == "Leaf"
        leaf_objs[path[0].id] = process_path(path[1:])
    return leaf_objs


def merge_type_sets(type_sets: List[TypeSet]) -> TypeSet:
    if len(type_sets) == 0:
        raise Exception("Attempted to merge empty type set")
    elif len(type_sets) == 1:
        return type_sets[0]
    else:
        head = type_sets[0]
        for tail in type_sets[1:]:
            head = head.union(tail)
        return head


def circular_unreplacer(
    abv: AbstractValue, remove_fields: List[str] = ["[Circular]"]
) -> AbstractValue:
    """
    Remove circular references from an AbstractValue
    """
    for key in abv.structure.keys():
        if key == "[Circular]":
            remove_fields.extend(list(abv.structure["[Circular]"].structure.keys()))
    new_structure: Dict[str, AbstractValue] = {}
    for k, v in abv.structure.items():
        if k in remove_fields:
            continue
        new_structure[k] = circular_unreplacer(v, remove_fields)
    return AbstractValue(
        abv.id, abv.type_set, new_structure, abv.constraints, abv.concrete
    )


def merge_objs(leaf_objs: List[AbstractValue]) -> AbstractValue:
    struct: Dict[str, AbstractValue] = {}
    for leaf_obj in leaf_objs:
        if leaf_obj.structure != {}:
            for k, v in leaf_obj.structure.items():
                if k not in struct:
                    struct[k] = v
                else:
                    struct[k] = merge_objs([struct[k], v])
    leaf_type_sets = merge_type_sets([a.type_set for a in leaf_objs])
    constraints: List[str] = []
    for leaf_obj in leaf_objs:
        constraints.extend(leaf_obj.constraints)
    merged_id = ""
    ids = [a.id for a in leaf_objs if a.id != ""]
    if ids:
        merged_id = ";".join(ids)
    abv = AbstractValue(merged_id, leaf_type_sets, struct, constraints)
    return circular_unreplacer(abv)


class OperationTreeNode(object):
    def __init__(
        self,
        id: str,
        name: Any,
        children: List["OperationTreeNode"],
        types: List[str] = [],
    ):
        self._id = id
        self._name = name
        self._children = children
        self._types = types

    @property
    def id(self) -> str:
        """
        ID of the operation
        """
        return self._id

    @property
    def name(self) -> Any:
        """
        Name of the operation
        """
        return self._name

    @name.setter
    def name(self, name):
        """
        Set name of the operation
        """
        self._name = name

    @property
    def children(self) -> List["OperationTreeNode"]:
        """
        Children of the operation
        """
        return self._children

    @property
    def types(self) -> List[str]:
        """
        Types of the operation
        """
        return self._types

    def to_json(self) -> object:
        """
        Convert to JSON-serializable object
        """
        return {
            "id": self.id,
            "name": self.name,
            "children": [c.to_json() for c in self.children],
            "types": self._types,
        }

    def __repr__(self):
        """
        Convert to JSON string
        """
        return json.dumps(self.to_json(), indent=4)


def get_inferred_types(abstract_value: AbstractValue, id: str) -> List[str]:
    """
    Get the inferred types of an AbstractValue
    """
    if abstract_value.id == id:
        return abstract_value.type_set.as_list()
    else:
        for _, inner_abstract_value in abstract_value.structure.items():
            types = get_inferred_types(inner_abstract_value, id)
            if types:
                return types
    return []


def maybe_coerce_to_string(tree: OperationTreeNode) -> Optional[OperationTreeNode]:
    """
    Coerce a tree to a string if it is not a literal or None
    """
    if len(tree.types) > 0:
        return OperationTreeNode("implicit", "coerce", [tree], ["Function:*->String"])
    elif tree.name != "None":
        return tree
    else:
        return None


def maybe_coerce_children(children: List[OperationTreeNode]) -> List[OperationTreeNode]:
    """
    Coerce children to strings if they are not literals or None
    """
    coerced_children = []
    for child in children:
        coerced_child = maybe_coerce_to_string(child)
        if coerced_child:
            coerced_children.append(coerced_child)
    return coerced_children


def sink_coercion_heuristic(
    children: List[OperationTreeNode],
) -> List[OperationTreeNode]:
    # Coerce each sink input to a string
    coerced_children = maybe_coerce_children(children)
    if len(coerced_children) == 0:
        # No children post-coercion; fallback to original children
        return children
    elif len(coerced_children) == 1:
        return coerced_children
    else:
        # Concatenate the sink inputs
        return [
            OperationTreeNode(
                "implicit", "concat", coerced_children, ["Function:*->String"]
            )
        ]


def generate_operation_tree(
    ptree: PTreeNode,
    abstract_value: AbstractValue,
    _depth: int = 0,
) -> List[OperationTreeNode]:
    """
    Generate an operation tree from a PTree
    """
    sinks = ["exec", "execSync", "eval", "spawn", "spawnSync", "spawnWithSignal", "Function"]
    keep = {
        "concat": "Function:*->String",
        "substr": "Function:String->String",
        "slice": "Function:String->String",
        "replace": "Function:String->String",
        "join": "Function:Array->String",
        "Unary": "Function:Number->Number",
    }
    parents: List[OperationTreeNode] = []
    for parent in ptree.parents:
        parents.extend(generate_operation_tree(parent, abstract_value, _depth + 1))
    # Only accept sinks at depth 0; otherwise, it may not actually be a sink
    if ptree.operation in sinks and _depth == 0:
        return [
            OperationTreeNode(
                ptree.id,
                ptree.operation if ptree.operation != "Untainted" else str(ptree.value),
                sink_coercion_heuristic(parents),
                ["Function:*->Undefined"],
            )
        ]
    elif ptree.operation in keep.keys() and ptree.operation_sign != "call:":
        if ptree.operation == "concat":
            parents = [
                OperationTreeNode(
                    "implicit",
                    "coerce",
                    [parent],
                    ["Function:*->String"],
                )
                for parent in parents
            ]
        elif ptree.operation == "join":
            parents[0] = OperationTreeNode(
                "implicit",
                "coerce",
                [parents[0]],
                ["Function:*->String"],
            )
        return [
            OperationTreeNode(
                ptree.id,
                ptree.operation,
                parents,
                [keep[ptree.operation]],
            )
        ]
    elif ptree.operation == "GetField":
        types = get_inferred_types(abstract_value, ptree.id)
        return [OperationTreeNode(ptree.id, "SymbolicField", [], types)]
    elif ptree.operation == "Untainted":
        types = get_inferred_types(abstract_value, ptree.id)
        # TODO: Should we perform str(ptree.value)?
        return [OperationTreeNode(ptree.id, ptree.value, [], types)]
    elif ptree.operation == "Tainted":
        # Need to use the parent ID because that is where the taint was applied
        types = get_inferred_types(abstract_value, ptree.parents[0].id)
        return [OperationTreeNode(ptree.parents[0].id, "SymbolicInput", [], types)]
    else:
        return parents


def _insert_solved_fields(abstract_value: AbstractValue, solved: Dict[str, str]):
    """
    Insert solved fields into an AbstractValue
    """
    inserted = False
    ids_to_check = []
    if ";" in abstract_value.id:
        ids_to_check = list(set(abstract_value.id.split(";")))
    else:
        ids_to_check = [abstract_value.id]
    for id in ids_to_check:
        if id in solved:
            if abstract_value.concrete:
                abstract_value.set_concrete(abstract_value.concrete + solved[id])
            else:
                abstract_value.set_concrete(solved[id])
            inserted = True
    if not inserted:
        for _, inner_abstract_value in abstract_value.structure.items():
            _, inserted = _insert_solved_fields(inner_abstract_value, solved)
    if not inserted:
        # Could not find ID in solution, so just use the first one
        solved_values = list(solved.values())
        if len(solved_values) > 1:
            abstract_value.set_concrete("".join([str(x) for x in solved_values]))
        elif len(solved_values) == 1:
            abstract_value.set_concrete(solved_values[0])
        else:
            abstract_value.set_concrete("")
    return abstract_value, inserted


def insert_solved_fields(abstract_value: AbstractValue, solved: Dict[str, str]):
    abstract_value, _ = _insert_solved_fields(abstract_value, solved)
    return abstract_value


def simplify_abstract_value_json(abstract_value: AbstractValue) -> AbstractValueJson:
    """
    Compress an AbstractValueJson by reducing concretized fields to their concrete
    values
    """
    abstract_value_json = abstract_value.to_json()
    for k, v in abstract_value_json["structure"].items():
        if "concrete" in v:
            abstract_value_json["structure"][k] = v["concrete"]  # type: ignore
        else:
            abstract_value_json["structure"][k] = simplify_abstract_value_json(v)
    return abstract_value_json

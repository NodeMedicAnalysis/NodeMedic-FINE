from enum import Enum
from random import sample, randint
from time import time
from typing import Any, List, Optional, Tuple, cast
import uuid

import z3

from .inference import OperationTreeNode
from ..enumerator.traverse_graph import (
    from_prefix_to_completion,
    from_prefix_to_template,
    from_prefix_to_state,
)
from ..enumerator.template import Literal, Identifier, FreshIdentifier, GetField, Payload

INVALID_VARS = ['return'] # Invalid variable names

class OperationTreeNodeType(Enum):
    """
    Represents the type of an OperationTreeNode.
    """

    SINK = 0
    LITERAL = 1
    SYMBOLIC = 2
    MODELED_OP = 4
    UNMODLED_OP = 5
    COERCION = 6


def use_funx_heuristic_aux(completion):
    ''' If first element of completion shows this is a return statement, and the last before the payload is a semi-colon ; try converting it into an addition + '''
    if len(completion) < 2:
        return completion
    
    if isinstance(completion, str):
        if completion.startswith('return') and completion.endswith(';'):
            return completion[:-1] + '+'
        else:
            return completion

    if completion[0].value.startswith('return'):
        for i in range(len(completion)):
            if isinstance(completion[i], Payload):
                break
        else:
            return completion

        i = i - 1
        if completion[i].value.endswith(';'):
            completion[i].value = completion[i].value[:-1] + '+'
            
    return completion

def use_func_heuristic(completions):
    return list(map(use_funx_heuristic_aux, completions))


class SMTGenerator:
    """
    Generates SMT-LIB2 code from an OperationTreeNode.

    Explanation of parameters:
    - tree: The OperationTreeNode to generate SMT-LIB2 code from
    - allow_unsound: Whether to allow unsound assumptions in the generated SMT-LIB2 code
    - use_enumerator: Whether to use the enumerator to generate payloads for eval
    - use_enumerator_templates: Whether to use templates from the enumerator rather
        that just concrete values for eval payloads
    - polyglot_aci_payload: Whether to solve for a polyglot ACI payload or use
        the default NodeMedic payload
    - polyglot_ace_payload: Whether to solve for a polyglot ACE payload or use
        the default NodeMedic payload
    - only_string_datatype: Whether to only consider the string type in synthesis;
        this matches the behavior of NodeMedic
    """
    def __init__(self,
        tree: OperationTreeNode,
        allow_unsound: bool = False,
        use_enumerator: bool = False,
        use_enumerator_templates: bool = False,
        use_polyglot_aci_payload: bool = False,
        use_polyglot_ace_payload: bool = False,
        only_string_datatype: bool = False,
    ):
        self._tree = tree
        self._formula: Optional[Any] = None
        self._context: List[Any] = []
        self._allow_unsound = allow_unsound
        self._use_enumerator = use_enumerator
        self._use_enumerator_templates = use_enumerator_templates
        self._use_polyglot_aci_payload = use_polyglot_aci_payload
        self._use_polyglot_ace_payload = use_polyglot_ace_payload
        self._only_string_datatype = only_string_datatype

    def classify_node(self, tree: OperationTreeNode) -> OperationTreeNodeType:
        """
        Classifies a node as one of the following:
        - SINK: A sink node, e.g. exec, eval
        - LITERAL: A literal node, e.g. "hello", 123
        - SYMBOLIC: A symbolic node, e.g. attacker-controllable input
        - MODELED_OP: A modeled operation node, e.g. concat, substr, slice, replace
        - UNMODELED_OP: An unmodeled operation node, e.g. split, join, etc.
        """
        if len(tree.children) == 0:
            if tree.name == "SymbolicField" or tree.name == "SymbolicInput":
                return OperationTreeNodeType.SYMBOLIC
            else:
                return OperationTreeNodeType.LITERAL
        if tree.name in ["exec", "execSync", "spawn", "spawnSync", "spawnWithSignal", "eval", "Function"]:
            return OperationTreeNodeType.SINK
        elif tree.name in ["concat", "substr", "slice", "replace", "join", "Unary"]:
            return OperationTreeNodeType.MODELED_OP
        elif tree.name in ["coerce"]:
            return OperationTreeNodeType.COERCION
        else:
            return OperationTreeNodeType.UNMODLED_OP

    def generate(self) -> str:
        """
        Generates SMT-LIB2 code from the OperationTreeNode.
        """
        core_assert = self._generate(self._tree)
        if self._context:
            self._formula = z3.And(core_assert, *self._context)
        else:
            self._formula = core_assert
        solver = z3.Solver()
        solver.add(self._formula)
        # sexpr = "(set-option :smt.string_solver z3str3)\n"
        sexpr = ""
        sexpr += solver.sexpr()
        sexpr += "\n(check-sat)\n(get-model)"
        return sexpr

    def _generate(self, tree: OperationTreeNode) -> z3.ExprRef:
        """
        Generates a Z3 formula from an OperationTreeNode.
        """
        node_type = self.classify_node(tree)
        if node_type == OperationTreeNodeType.SINK:
            return self.generate_sink(tree)
        elif node_type == OperationTreeNodeType.LITERAL:
            return self.generate_literal(tree)
        elif node_type == OperationTreeNodeType.SYMBOLIC:
            return self.generate_symbolic(tree)
        elif node_type == OperationTreeNodeType.MODELED_OP:
            return self.generate_modeled_op(tree)
        elif node_type == OperationTreeNodeType.COERCION:
            return self.generate_coerce_op(tree)
        elif node_type == OperationTreeNodeType.UNMODLED_OP:
            return self.generate_unmodeled_op(tree)
        else:
            raise Exception(f"Unknown node type: {node_type}")

    def construct_exec_payloads(self) -> List[str]:
        """
        Constructs payloads for the exec sink.
        """
        prefix_list = [" ", "; ", "&& "]
        payload_list = [
            "touch /tmp/success",
            "$(touch /tmp/success)",
            "`touch /tmp/success`",
        ]
        suffix_list = [";#"]
        if self._use_polyglot_aci_payload:
            payload_list.append(
                '$(touch /tmp/success) # " || touch /tmp/success # \' || touch /tmp/success'
            )
            suffix_list = [""]
        payloads: List[str] = []
        for prefix in prefix_list:
            for payload in payload_list:
                for suffix in suffix_list:
                    payloads.append(f"{prefix}{payload}{suffix}")
        return payloads

    def concretize_tree(self, tree: OperationTreeNode) -> str:
        node_type = self.classify_node(tree)
        if node_type == OperationTreeNodeType.LITERAL:
            return str(tree.name)
        elif node_type == OperationTreeNodeType.SYMBOLIC:
            return "SYMBOLIC"
        else:
            return "".join([self.concretize_tree(child) for child in tree.children])

    def extract_prefix_from_tree(self, tree: OperationTreeNode) -> str:
        # Rephrase tree as list of concatenations LHS to symbolic input
        concretized_tree = self.concretize_tree(tree)
        index_of_first_symbolc = concretized_tree.find("SYMBOLIC")
        return concretized_tree[:index_of_first_symbolc]

    def generate_concrete_alternative_payloads(
        self,
        sink_input: z3.ExprRef,
        completions: List[str],
        exploit_command: str,
        max_completions: int = 3,
    ):
        if len(completions) == 1:
            return cast(
                z3.ExprRef, z3.Contains(sink_input, completions[0] + exploit_command)
            )
        else:
            # Heuristic to improve solving time
            completions = sample(completions, len(completions))[
                : min(len(completions), max_completions)
            ]
            return cast(
                z3.ExprRef,
                z3.Or(
                    *[
                        z3.Contains(sink_input, completion + exploit_command)
                        for completion in completions
                    ]
                ),
            )

    def construct_eval_payloads(
        self, sink_input: OperationTreeNode, concrete=True
    ) -> z3.ExprRef:
        # Extract the prefix of the sink input
        prefix = self.extract_prefix_from_tree(sink_input)

        with open(f'/nodetaint/analysisArtifacts/{randint(1,2**64)}.prefix', 'w') as f:
            f.write(prefix)

        # Call the enumerator on the LHS to produce a template
        completions = []
        if concrete:
            for component in from_prefix_to_completion(prefix):
                completions.append(component)
        else:
            completions = list(from_prefix_to_template(prefix, max_states=2, max_completions=2))
        # Add a default completion LiteralÃŸ
        if len(completions) == 0:
            if concrete:
                completions.append("")
            else:
                completions.append([Literal("")])
        # Subtract prefixes from completions
        exploit_command = "global.CTF()"
        if self._use_polyglot_ace_payload:
            exploit_command = 'global.CTF();//"+global.CTF();//\'+global.CTF();//${global.CTF()}'
        comment_command = "//"

        completions = use_func_heuristic(completions)

        if concrete:
            constraints = self.generate_concrete_alternative_payloads(
                self._generate(sink_input), completions, exploit_command + comment_command
            )
            return constraints
        else:
            template = completions[0]
            # Construct SMT constraints from the template
            constraints = self.construct_constraints_from_template(
                self._generate(sink_input), template, exploit_command, comment_command
            )
            return constraints
        
    def gen_id(self) -> str:
        return str(uuid.uuid4())[:8]
    
    def js_identifier_constraints(self, val: z3.ExprRef, start: str, invalid: List[str]):
        # Z3 constraints encoding a valid JS identifier
        self._context.append(z3.Length(val) >= 1)
        self._context.append(z3.Length(val) <= 50) # Not necessary, but sufficient
        self._context.append(z3.InRe(val, z3.Star(z3.Range("a", "z")))) # Overly restrictive
        if start:
            suffix = z3.String(f"TemplateIdentifier_suffix_{self.gen_id()}")
            self._context.append(val == z3.Concat(z3.StringVal(start), suffix))
        if invalid:
            for inv in invalid:
                self._context.append(val != inv)

    def common_object_properties_constraint(self, val: z3.ExprRef):
        # Z3 constraints encoding common object properties
        self._context.append(z3.Or(
            val == "constructor", 
            val == "__proto__",
            val == "hasOwnProperty",
            val == "toString",
            val == "valueOf",
            val == "toLocaleString",
            val == "isPrototypeOf",
            val == "propertyIsEnumerable",
        ))
        
    def construct_constraints_from_template(
        self,
        sink_input: z3.ExprRef,
        template: List[object],
        exploit_command: str,
        comment_command: str,
        max_completions: int = 3,
    ) -> z3.ExprRef:
        prefix_completion = []
        injected_payload = False

        for item in template:
            if isinstance(item, Literal):
                prefix_completion.append(z3.StringVal(item.value))
            elif isinstance(item, Identifier):
                val = z3.String(f"TemplateIdentifier_{self.gen_id()}")
                prefix_completion.append(val)
                self.js_identifier_constraints(val, item.value, INVALID_VARS)
            elif isinstance(item, FreshIdentifier):
                val = z3.String(f"TemplateFreshIdentifier_{self.gen_id()}")
                prefix_completion.append(val)
                #prefix_completion.append(self.gen_id())
                self.js_identifier_constraints(val, item.value, INVALID_VARS)
            elif isinstance(item, GetField):
                val = z3.String(f"TemplateGetField_{self.gen_id()}")
                prefix_completion.append(val)
                self.common_object_properties_constraint(val)
            elif isinstance(item, Payload):
                val = z3.StringVal(exploit_command)
                prefix_completion.append(val)
                injected_payload = True
            else:
                raise Exception(f"Unknown template item: {type(item)}")

        if not injected_payload:
            prefix_completion.append(z3.StringVal(';'))
            prefix_completion.append(z3.StringVal(exploit_command))
        prefix_completion.append(z3.StringVal(comment_command))

        return z3.Contains(sink_input, z3.Concat(*prefix_completion))
    
    def check_sink_input_inclusion(self, sink_input, value):
        if type(sink_input) == z3.ArrayRef:
            return z3.Select(sink_input, z3.IntVal(0)) == value
        elif type(sink_input) == z3.SeqRef:
            return z3.Contains(sink_input, value)
        else:
            raise Exception(f"Unknown sink input type: {type(sink_input)}")

    def generate_sink(self, tree: OperationTreeNode) -> z3.ExprRef:
        """
        Generates a Z3 formula for a sink node.
        """
        if (tree.name == "exec" 
            or tree.name == "execSync"
            or tree.name == "spawn"
            or tree.name == "spawnSync"
            or tree.name == "spawnWithSignal"):
            sink_input = self._generate(tree.children[0])
            if self._context != []:
                return cast(
                    z3.ExprRef,
                    z3.Or(
                        *[
                            self.check_sink_input_inclusion(sink_input, payload)
                            for payload in self.construct_exec_payloads()
                        ]
                    ),
                )
            else:
                # Shortcut that assumes we don't have any replacements
                payload = " $(touch /tmp/success);#"
                if self._use_polyglot_aci_payload:
                    payload = ' $(touch /tmp/success) # " || touch /tmp/success # \' || touch /tmp/success'
                return self.check_sink_input_inclusion(sink_input, payload)
        elif tree.name == "eval" or tree.name == "Function":
            if self._use_enumerator:
                return self.construct_eval_payloads(
                    tree.children[0],
                    concrete=(not self._use_enumerator_templates)
                )
            else:
                sink_input = self._generate(tree.children[0])
                return self.check_sink_input_inclusion(
                    sink_input, 
                    ".__proto__+global.CTF();//"
                )
        else:
            raise Exception(f"Unknown sink: {tree.name}")

    def generate_literal(self, tree: OperationTreeNode) -> z3.ExprRef:
        """
        Generates a Z3 formula for a literal node.
        """
        if self._only_string_datatype:
            return z3.StringVal(str(tree.name))
        if isinstance(tree.name, str):
            if tree.name.isnumeric():
                tree.name = int(tree.name)
                return self.generate_literal(tree)
            return z3.StringVal(tree.name)
        elif isinstance(tree.name, int):
            return z3.IntVal(tree.name)
        elif isinstance(tree.name, dict) and self._allow_unsound:
            # Unsoundly convert objects to strings
            return z3.StringVal(str(tree.name))
        elif isinstance(tree.name, list) and self._allow_unsound:
            # Unsoundly assume that all arrays contain strings
            return z3.Array(f"Array_{tree.id}", z3.IntSort(), z3.StringSort())
        elif tree.name is None and self._allow_unsound:
            # Unsoundly assume that values without inferred types are strings
            return z3.String(f"Unknown_{tree.id}")
        else:
            raise Exception(f"Unknown literal type: {type(tree.name)}")

    def generate_symbolic(self, tree: OperationTreeNode) -> z3.ExprRef:
        """
        Generates a Z3 formula for a symbolic node.
        """
        if self._only_string_datatype:
            return z3.String(f"{tree.name}_{tree.id}")
        if "String" in tree.types:
            return z3.String(f"{tree.name}_{tree.id}")
        elif "Number" in tree.types:
            return z3.Int(f"{tree.name}_{tree.id}")
        elif "Boolean" in tree.types:
            return z3.String(f"{tree.name}_{tree.id}")
        elif ("Object" in tree.types or "Bot" in tree.types) and self._allow_unsound:
            # Unsoundly assume that all objects are strings
            return z3.String(f"{tree.name}_{tree.id}")
        elif "Array" in tree.types and self._allow_unsound:
            # Unsoundly assume that all arrays contain strings
            return z3.Array(f"Array_{tree.id}", z3.IntSort(), z3.StringSort())
        elif "RegExp" in tree.types and self._allow_unsound:
            # Unsoundly assume that all regexes are strings
            return z3.String(f"RegExp_{tree.id}")
        elif "Date" in tree.types:
            # Assume that dates are strings
            return z3.String(f"Date_{tree.id}")
        elif "Map" in tree.types or "WeakMap" in tree.types and self._allow_unsound:
            # Fall back to string-only generation
            return z3.String(f"Map_{tree.id}")
        elif tree.types == [] and self._allow_unsound:
            # Unsoundly assume that values without inferred types are strings
            return z3.String(f"Unknown_{tree.id}")
        else:
            raise Exception(f"Unknown symbolic type: {tree.types}")

    def _generate_coerce_string(
        self, child: OperationTreeNode, child_types: List[str]
    ) -> z3.ExprRef:
        if self._only_string_datatype:
            return self._generate(child)
        if "String" in child_types:
            return self._generate(child)
        elif "Number" in child_types:
            return z3.IntToStr(self._generate(child))
        elif "Boolean" in child_types:
            val = self._generate(child)
            self._context.append(
                z3.Or(
                    val == z3.StringVal("true"),
                    val == z3.StringVal("false"),
                )
            )
            return val
        elif ("Object" in child_types or "Bot" in child_types) and self._allow_unsound:
            # Unsoundly attempt to coerce to string
            return self._generate(child)
        elif "Array" in child_types or isinstance(child.name, list) and self._allow_unsound:
            # Unsoundly just retrieve the first element
            return z3.Select(
                self._generate(child),
                z3.IntVal(0),
            )
        elif len(child_types) == 1 and "Function" in child_types[0]:
            parsed_type = child.types[0].split(":")[1].split("->")[1]
            return self._generate_coerce_string(child, [parsed_type])
        elif len(child.children) == 0:
            # We pass through for untainted values
            return self._generate(child)
        else:
            raise Exception(f"Unhandled coerce from {child.types} to String")

    def generate_coerce_op(self, tree: OperationTreeNode) -> z3.ExprRef:
        # Coerce is a unary operation
        assert (
            len(tree.children) == 1
        ), f"Unhandled coerce child count: {len(tree.children)}"
        child = tree.children[0]
        # Determine what we are coercing to
        to_type = None
        assert len(tree.types) == 1, f"Unhandled coerce type: {tree.types}"
        to_type = tree.types[0].split(":")[1].split("->")[1]
        if to_type == "String":
            return self._generate_coerce_string(child, child.types)
        else:
            raise Exception(f"Unhandled coerce-to type: {to_type}")
        
    def _force_coerce_to_string(self, val: z3.ExprRef) -> z3.ExprRef:
        if self._only_string_datatype:
            return val
        if z3.is_string(val):
            return val
        elif z3.is_int(val):
            return z3.IntToStr(val)
        elif z3.is_array(val) and self._allow_unsound:
            return z3.Select(val, z3.IntVal(0))
        else:
            raise Exception(f"Unhandled coerce to string: {val}")
        
    def coerce_to_string(self, tree: OperationTreeNode) -> z3.ExprRef:
        val = self._generate_coerce_string(tree, tree.types)
        return self._force_coerce_to_string(val)

    def generate_modeled_op(self, tree: OperationTreeNode) -> z3.ExprRef:
        """
        Generates a Z3 formula for a modeled operation node.
        """
        if tree.name == "concat":
            children = [self.coerce_to_string(child) for child in tree.children]
            return z3.Concat(*children)
        elif tree.name == "substr":
            return z3.SubString(
                self.coerce_to_string(tree.children[0]),
                self._generate(tree.children[1]),
                self._generate(tree.children[2]),
            )
        elif tree.name == "slice":
            val = self.coerce_to_string(tree.children[0]),
            length = self._generate(tree.children[2])
            if int(str(length)) < 0:
                length = z3.Length(val) + length
            return z3.Extract(
                val,
                self._generate(tree.children[1]),
                length,
            )
        elif tree.name == "replace":
            self._context.append(
                z3.Not(
                    z3.Contains(
                        self.coerce_to_string(tree.children[0]),
                        self.coerce_to_string(tree.children[1]),
                    )
                )
            )
            return self._generate(tree.children[0])
        elif tree.name == "join" and self._allow_unsound:
            if "Array" in tree.children[0].types:
                return z3.Concat(
                    self.coerce_to_string(tree.children[0]),
                    self.coerce_to_string(tree.children[1]),
                )
            else:
                if len(tree.children) == 0:
                    return "",
                elif len(tree.children) == 1:
                    return self.coerce_to_string(tree.children[0])
                return z3.Concat(
                    *[self.coerce_to_string(child) for child in tree.children]
                )
        elif tree.name == "Unary":
            child = self._generate(tree.children[0])
            if isinstance(child, z3.ArithRef):
                return -child
            else:
                raise Exception(f"Unhandled unary operand: {child}")
        else:
            raise Exception(f"Unknown modeled op: {tree.name}")

    def generate_unmodeled_op(self, tree: OperationTreeNode) -> z3.ExprRef:
        """
        Generates a Z3 formula for an unmodeled operation node.
        """
        raise Exception(f"Unmodeled op: {tree.name}")

    def solve(self, solving_time: int = 10) -> Tuple[str, float]:
        """
        Solves the generated SMT-LIB2 formula.
        Accepts a solving time in seconds.
        Returns a tuple of (result, elapsed_time).
        Elapsed time is in seconds.
        """
        assert self._formula is not None, "Formula is None"
        solver = z3.Solver()
        timeout_milliseconds = solving_time * 1000
        solver.set("timeout", timeout_milliseconds)
        # solver.set("smt.string_solver", "z3str3")
        solver.add(self._formula)
        start = time()
        check_result = solver.check()
        elapsed = time() - start
        if check_result == z3.sat:
            return (self.solver_model_to_json(solver.model()), elapsed)
        elif check_result == z3.unsat:
            return ("unsat", elapsed)
        elif check_result == z3.unknown:
            return ("unknown", elapsed)
        else:
            raise Exception(f"Unknown check result: {check_result}")

    def parse_assignment(self, model, assignment: z3.AstRef) -> object:
        """
        Parses a Z3 assignment into a Python object.
        """
        if z3.is_string(assignment):
            return assignment.as_string()
        elif z3.is_int(assignment):
            return int(assignment)
        elif z3.is_array(assignment) and self._allow_unsound:
            # Simplified single-element model
            return [self.parse_assignment(model, model.eval(assignment[0]))]
        else:
            raise Exception(f"Unknown assignment type: {type(assignment)}")

    def solver_model_to_json(self, model: z3.ModelRef) -> str:
        """
        Converts a Z3 model to JSON.
        """
        result = {}
        for decl in model.decls():
            if decl.arity() > 0:
                raise Exception("uninterpreted functions are not supported")
            name = decl.name()
            if "_" in name:
                name = name.split("_")[1]
            val = model[decl]
            result[name] = self.parse_assignment(model, val)
        return result

import { writeFileSync } from "fs";


function checkUndefined<T>(data: T | undefined, errMsg?: string): T {
    if (data === undefined) {
        if (errMsg === undefined) {
            errMsg = ''
        }
        throw Error(`Data was undefined\n${errMsg}`);
    }
    return data;
}


// Mapping friendly names to all JavaScript builtin primitive types
const builtinTypes = {
    'Array': [],
    'BigInt': BigInt(0),
    'Boolean': true,
    'Number': 0,
    'Object': {},
    'String': '',
    'Symbol': Symbol('symbol'),
    // Undefined and null have no fields
    // 'Undefined': undefined,
    // 'Null': null,
};

// We can also apply this methodology to builtin objects
const builtinObjects = {
    // 'Date': new Date(),
    // 'Error': new Error(),
    'Map': new Map(),
    // 'RegExp': new RegExp(''),
    'Set': new Set(),
    'WeakSet': new Set(),
    'WeakMap': new Map(),
};


// All of the types we will process:
const types = {
    ...builtinTypes,
    ...builtinObjects,
};


// This will store all seen fields
let allFields = new Set<string>();


// This will map types to the fields they have
let fieldSets = new Map<string, Set<string>>();
for(const typeName in types) {
    fieldSets.set(typeName, new Set());
}


// This will store unique fields for each type
let uniqueFieldSets = new Map<string, Set<string>>();
for(const typeName in types) {
    uniqueFieldSets.set(typeName, new Set());
}


// Union of two sets
function union<T>(a: Set<T>, b: Set<T>): Set<T> {
    return new Set([...a, ...b]);
}


// Get valid operations for each type
for (const typeName in types) {
    const instance = types[typeName];
    // List of all fields
    let fields: string[] = Object.getOwnPropertyNames(instance);
    try {
        // Attempt to get the fields of the prototype
        let protoFields: string[] = Object.getOwnPropertyNames(
            instance.__proto__
        );
        fields.push(...protoFields);
    } catch (err) {
        // Discard the error, if any
    }
    try {
        if (instance.constructor !== Symbol) {
            // Attempt to get the fields of the constructor
            let constructorFields: string[] = Object.getOwnPropertyNames(
                instance.constructor
            );
            fields.push(...constructorFields);
        }
    } catch (err) {
        // Discard the error, if any
    }
    // Covert to a set
    let fieldSet = new Set<string>();
    fields.map(field => fieldSet.add(field));
    // Add to global facts
    allFields = union(allFields, fieldSet);
    fieldSets.set(typeName, fieldSet);
}


// Duck typing: For each type
for (const field of allFields.values()) {
    // For each field we previously found
    for (const typeName in types) {
        const instance = types[typeName];
        // Try to see if we can access the field
        try {
            let result = instance[field];
            // If we can, add it to the fields of that type
            if (result !== undefined && result !== null) {
                let existingFields = checkUndefined(fieldSets.get(typeName));
                fieldSets.set(typeName, existingFields.add(field));
            }
        } catch (err) {
            // Discard the error
        }
    }
}


// Duck typing 2: Check for field access
allFields = allFields.add('FieldAccess');
for (const typeName in types) {
    const instance = types[typeName];
    try {
        if (Object.isExtensible(instance)) {
            let existingFields = checkUndefined(fieldSets.get(typeName));
            fieldSets.set(typeName, existingFields.add('FieldAccess'));
        }
    } catch (err) {
        // Discard the error
    }
}
// We need to manually add this for strings since they aren't
// listed as extensible but still support field access
let existingFields = checkUndefined(fieldSets.get('String'));
fieldSets.set('String', existingFields.add('FieldAccess'));


// This function assigns a canonical name to
// a set of types. 
// E.g., {String, Object} -> 'OS'
function canonicalTypeName(s: Set<string>): string {
    const sList: string[] = [...s];
    const sortedSList = sList.sort();
    // We can reduce the size here if we want
    // with x.substring(0, 2)
    const letterList = sortedSList.map(x => x);
    return letterList.join('|');
}

// Name mappings
let nameMappings = new Map<string, Set<string>>();
for(const typeName in types) {
    const selfSet = new Set([typeName]);
    nameMappings.set(canonicalTypeName(selfSet), selfSet);
}

// For creating the type transition lattice
let validSets = new Map<string, Set<string>>();
for(const typeName in types) {
    validSets.set(typeName, new Set());
}

// Derive unique fields
for (const field of allFields.values()) {
    // This stores all of the types this field is defined for
    let existsIn = new Set<string>();
    for (const [typeName, typeFields] of fieldSets) {
        if (typeFields.has(field)) {
            existsIn = existsIn.add(typeName);
        }
    }
    if (existsIn.size > 0) {
        // Derive a name for this set of types
        let name = canonicalTypeName(existsIn);
        if (name == '') {
            throw Error(`Invalid canonical name generated`);
        }
        nameMappings.set(name, existsIn);
        validSets.set(name, existsIn);
        // Add to the global facts of unique fields
        if (!uniqueFieldSets.has(name)) {
            uniqueFieldSets.set(name, new Set<string>());
        }
        let existingSet = checkUndefined(uniqueFieldSets.get(name));
        uniqueFieldSets.set(name, existingSet.add(field));
    }
}


// Convert to friendly JSON representation
let categories = {};
for (const [typeName, typeFields] of uniqueFieldSets) {
    for (const field of typeFields) {
        if (Object.keys(categories).indexOf(field) != -1) {
            throw Error(`Unhandled: Overwriting field: ${field}`);
        }
        categories[field] = typeName;
    }
}


// Output field-to-set mapping
let output = JSON.stringify(
    categories, 
    null,
    4
);

writeFileSync('./categories.json', output);


// Convert the map of type sets (storing all unique sets) to an array
let sortedValidSets = Array.from(
    validSets.values()
).sort(function(a: Set<string>, b: Set<string>): number {
    return b.size - a.size;
}).filter(function (value: Set<string>) {
    return value.size > 0;
})

// Check if b is a subset of a (including if a == b)
function subsetEq<T>(a: Set<T>, b: Set<T>): boolean {
    for (const v of b.values()) {
        if (!a.has(v)) {
            return false;
        }
    }
    return true;
}

// Check if b has any elements in common with a
function intersect<T>(a: Set<T>, b: Set<T>): Set<T> {
    let res: Set<T> = new Set();
    for (const v of b.values()) {
        if (a.has(v)) {
            res = res.add(v);
        }
    }
    return res;
}


// Derive the lattice
let lattice = {};
for (const typeName of nameMappings) {
    lattice[typeName[0]] = {}
}


for (const s1 of sortedValidSets) {
    let c1 = canonicalTypeName(s1);
    if (Object.getOwnPropertyNames(lattice).indexOf(c1) == -1) {
        lattice[c1] = {};
    }
    for (const s2 of sortedValidSets) {
        let c2 = canonicalTypeName(s2);
        // Case 1: Transition to a new type set
        if (subsetEq(s1, s2)) {
            lattice[c1][`Builtin<${c2}>`] = c2;
        // Case 2: Stay at the same type set
        } else if (intersect(s1, s2).size != 0) {
            lattice[c1][`Builtin<${c2}>`] = c1;
        }
    }
}


let fieldAccessSet = checkUndefined(nameMappings.get(categories['FieldAccess']));
for (const key of Object.keys(lattice)) {
    let typeSet1 = checkUndefined(nameMappings.get(key), `No name mapping for <${key}>`);
    // Transition operations cause us to return
    let intersection = intersect(fieldAccessSet, typeSet1);
    if (intersection.size != 0) {
        let intersectionName = canonicalTypeName(intersection);
        if (!lattice.hasOwnProperty(intersectionName)) {
            throw Error(`No name found for this intersection: ${Array.from(intersection)}`);
        }
        lattice[key]['->'] = intersectionName;
    } else {
        lattice[key]['->'] = 'Top';
    }
}

// Add the bottom element
lattice['Bot'] = {};
for (const key of Object.keys(lattice)) {
    lattice['Bot'][`Builtin<${key}>`] = key
}
lattice['Bot']['->'] = categories['FieldAccess'];

// Add default transitions
for (const key of Object.keys(lattice)) {
    // Unhandled operations cause us to stay
    lattice[key]['*'] = key
}

for (const key of Object.keys(lattice)) {
    // Unexpected operations cause is to go to Top,
    // representing an invalid state
    lattice[key]['!'] = 'Top'
}

// Add the top element
lattice['Top'] = {}


// Output the lattice
let output2 = JSON.stringify(
    lattice, 
    null,
    4
);

writeFileSync('./lattice.json', output2);

from __future__ import annotations

from enum import Enum
from functools import partial
import json
from pathlib import Path
from sys import argv
from typing import Callable, Dict, List, Optional, Tuple, TypeVar, TypedDict, cast
import uuid

T = TypeVar("T")


class JSValueType(Enum):
    STRING = 1
    OBJECT = 2
    ARRAY = 3
    NUMBER = 4
    BOOLEAN = 5


class OperationConversion(object):
    MODELED_OPS = {
        "precise:string.concat": "concat",
        "imprecise:concat": "concat",
        "+": "concat",
        "precise:string.replace": "replace",
        "precise:string.slice": "slice",
        "model:string.split": "split",
        # Arrays
        "imprecise:join": "join",
        "model:array.join": "join",
    }

    @staticmethod
    def maybe_convert(operation: str) -> str:
        for k, v in OperationConversion.MODELED_OPS.items():
            if k in operation:
                return v
        return operation


class OperationSets(object):
    FIELD_ACCESS_OPS = ["GetField", "PutField"]
    SINKS = [
        "eval",
        "exec",
        "execSync",
        "Function",
        "spawn",
        "spawnSync",
        "spawnWithSignal",
    ]

    def __init__(self, categories_path: Path):
        with open(categories_path, "r") as cat_f:
            self._categories = json.load(cat_f)

    def has(self, field_name: str) -> bool:
        if field_name in self._categories:
            return True
        return False

    def get(self, field_name: str) -> str:
        if field_name in self._categories:
            return self._categories[field_name]
        raise Exception(f"Field name not present in categories: {field_name}")


class OperationType(object):
    def __init__(self):
        raise Exception("Do not call directly")


class BuiltinOperationType(OperationType):
    def __init__(self, name: str):
        self._name = name

    @property
    def name(self):
        return self._name

    def __repr__(self):
        return f"Builtin<{self.name}>"


class LiteralOperationType(OperationType):
    def __init__(self):
        pass

    def __repr__(self):
        return "Literal<>"


class FieldOperationType(OperationType):
    def __init__(self):
        pass

    def __repr__(self):
        return "Field<>"


class SinkOperationType(OperationType):
    def __init__(self):
        pass

    def __repr__(self):
        return "Sink<>"


class OtherOperationType(OperationType):
    def __init__(self):
        pass

    def __repr__(self):
        return "Other<>"


class PTreeAndDepth(TypedDict):
    node: PTreeNode
    depth: int


K = TypeVar("K")
V = TypeVar("V")
PyJsType = Dict[str, "PyJsType"] | str | int | bool | float | List["PyJsType"]


class PTreeNode(object):
    def __init__(
        self,
        operation: str,
        operation_type: OperationType,
        operation_sign: Optional[str],
        value: Optional[PyJsType],
        value_type: Optional[JSValueType],
        tainted: bool,
        parents: List[PTreeNode],
        children: List[PTreeNode],
        friendly_id: str,
    ):
        self._id = self.gen_id()
        self._operation = operation.strip()
        self._operation_sign = operation_sign
        self._operation_type = operation_type
        self._value = value
        self._value_type = value_type
        self._tainted = tainted
        self._parents = parents
        self._children = children
        self._friendly_id = friendly_id

    def gen_id(self) -> str:
        return str(uuid.uuid4())[:8]

    @property
    def id(self) -> str:
        return self._id

    @property
    def operation(self) -> str:
        return self._operation

    @property
    def operation_sign(self) -> Optional[str]:
        return self._operation_sign

    @property
    def operation_type(self) -> OperationType:
        return self._operation_type

    @property
    def value(self) -> Optional[PyJsType]:
        return self._value

    @property
    def value_type(self) -> Optional[JSValueType]:
        return self._value_type

    @property
    def tainted(self) -> bool:
        return self._tainted

    @property
    def parents(self) -> List[PTreeNode]:
        return self._parents

    @parents.setter
    def parents(self, lst: List[PTreeNode]):
        self._parents = lst

    @property
    def children(self) -> List[PTreeNode]:
        return self._children

    @children.setter
    def children(self, lst: List[PTreeNode]):
        self._children = lst

    @property
    def friendly_id(self) -> str:
        return self._friendly_id

    def map(
        self,
        fn: Callable[[PTreeAndDepth], None],
        for_parents: bool = True,
        _depth: int = 0,
    ) -> None:
        fn({"node": self, "depth": _depth})
        to_iter = self.parents if for_parents else self.children
        for node in to_iter:
            node.map(fn, for_parents, _depth + 1)

    def fold(
        self,
        acc: T,
        fn: Callable[[T, PTreeAndDepth], T],
        for_parents: bool = True,
        _depth: int = 0,
    ) -> T:
        acc = fn(acc, {"node": self, "depth": _depth})
        to_iter = self.parents if for_parents else self.children
        for node in to_iter:
            acc = node.fold(acc, fn, for_parents, _depth + 1)
        return acc

    def get_nodes(
        self, filter: Optional[Callable[[PTreeAndDepth], bool]] = None
    ) -> List[PTreeNode]:
        def folder(acc: List[PTreeNode], item: PTreeAndDepth) -> List[PTreeNode]:
            if not filter or filter(item):
                return acc + [item["node"]]
            return acc

        return self.fold([], folder)

    def to_string(self, _depth: int = 0, _verbose: bool = False) -> str:
        out = f'{"    " * _depth}'
        out += f"NODE: <<{self.operation}>> | ID:{self.id} | #{self.friendly_id}"
        if _verbose:
            out += f'\n{"    " * (_depth)}| OTYPE: {self.operation_type}'
            out += f'\n{"    " * (_depth)}| VTYPE: {self.value_type}'
            out += f'\n{"    " * (_depth)}| VALUE: <<{self.value}>>'
        return out

    def serialize_parents(self, verbose: bool = False) -> str:
        def output(acc: str, item: PTreeAndDepth):
            depth = item["depth"]
            return (
                acc
                + item["node"].to_string(depth, verbose)
                + f'\n{"    " * (depth)}| PARENTS:\n'
            )

        return self.fold("", output)

    def serialize_children(self, verbose: bool = False) -> str:
        out = ""
        for node in self.get_nodes():
            out += node.to_string(_verbose=verbose) + "\nCHILDREN: ["
            if node.children:
                out += "\n"
            for child in node.children:
                out += child.to_string(_depth=1, _verbose=verbose) + "\n"
            out += "]\n\n"
        return out

    def __repr__(self):
        return self.to_string()


class RawPTreeNode(TypedDict):
    operation: str
    value: PyJsType
    tainted: bool
    flows_from: List[str]


FlowsTo = Dict[str, List[str]]


class PTreeParser(object):
    def __init__(self):
        categories_path = Path(__file__).parent / "operation_types" / "categories.json"
        self.opsets = OperationSets(categories_path)

    def generate_flows_to(self, raw_ptree: Dict[str, RawPTreeNode]) -> FlowsTo:
        node_ids = list(raw_ptree.keys())
        flows_to: Dict[str, List[str]] = {}
        for node_id1 in node_ids:
            flows_to[node_id1] = []
            for node_id2 in node_ids:
                if node_id1 in raw_ptree[node_id2]["flows_from"]:
                    flows_to[node_id1].append(node_id2)
        return flows_to

    def unwrapHeuristic(self, val: PyJsType) -> Tuple[bool, PyJsType]:
        """
        Attempt to detect and reconstruct a string value
        """
        if type(val) != dict:
            return (False, val)
        if len(val.keys()) == 0:
            return (False, val)
        all_numeric_keys = True
        all_single_char_values = True
        for k, v in val.items():
            if not k.isnumeric():
                all_numeric_keys = False
                break
            if not ((isinstance(v, str) or isinstance(v, list)) and len(v) == 1):
                all_single_char_values = False
                break
        if all_numeric_keys and all_single_char_values:
            val_values: List[str] = cast(List[str], val.values())
            return (True, "".join(val_values))
        return (False, val)

    def recursiveUnwrap(self, obj: PyJsType) -> PyJsType:
        if type(obj) != dict:
            return obj
        was_unwrapped, obj = self.unwrapHeuristic(obj)
        if not was_unwrapped and type(obj) == dict:
            for k, v in obj.items():
                obj[k] = self.recursiveUnwrap(v)
        return obj

    def determine_value_type(self, value: Optional[PyJsType]) -> Optional[JSValueType]:
        if not value:
            return None
        if type(value) == str:
            return JSValueType.STRING
        if type(value) == dict:
            return JSValueType.OBJECT
        if type(value) == list:
            return JSValueType.ARRAY
        if type(value) == int:
            return JSValueType.NUMBER
        if type(value) == bool:
            return JSValueType.BOOLEAN
        raise Exception(f"No type determined for value: {value}")

    def remove_call_signs(self, operation: str) -> Tuple[str, Optional[str]]:
        signs = ["call:", "imprecise:", "precise:", "model:"]
        for sign in signs:
            if sign in operation:
                return operation.removeprefix(sign), sign
        return operation, None

    def remove_namespaces(self, operation: str) -> str:
        if "." in operation:
            return operation.split(".")[-1]
        return operation

    def determine_operation_type(
        self, operation: str, value: Optional[PyJsType]
    ) -> OperationType:
        if self.opsets.has(operation):
            return BuiltinOperationType(self.opsets.get(operation))
        if operation in OperationSets.SINKS:
            return SinkOperationType()
        for field_access_op in OperationSets.FIELD_ACCESS_OPS:
            if field_access_op in operation:
                return FieldOperationType()
        if isinstance(value, str) and self.opsets.has(value):
            return BuiltinOperationType(self.opsets.get(value))
        return OtherOperationType()

    def parse_raw(
        self,
        raw_ptree: Dict[str, RawPTreeNode],
        id_to_node: Dict[str, PTreeNode],
        node_to_id: Dict[PTreeNode, str],
        node_id: str = "1",
    ) -> PTreeNode:
        current = raw_ptree[node_id]
        converted_operation = OperationConversion.maybe_convert(current["operation"])
        converted_operation, sign = self.remove_call_signs(converted_operation)
        converted_operation = self.remove_namespaces(converted_operation)
        if "value" in current:
            unwrapped_value = self.recursiveUnwrap(current["value"])
        else:
            unwrapped_value = None
        ptree = PTreeNode(
            operation=converted_operation,
            operation_sign=sign,
            operation_type=self.determine_operation_type(
                converted_operation, unwrapped_value
            ),
            value=unwrapped_value,
            value_type=self.determine_value_type(unwrapped_value),
            tainted=current["tainted"],
            parents=[],
            children=[],
            friendly_id=node_id,
        )
        id_to_node[node_id] = ptree
        node_to_id[ptree] = node_id
        parents: List[PTreeNode] = []
        for parent_id in current["flows_from"]:
            if parent_id in id_to_node:
                parents.append(id_to_node[parent_id])
            else:
                parents.append(
                    self.parse_raw(raw_ptree, id_to_node, node_to_id, parent_id)
                )
        ptree.parents = parents
        return ptree

    def add_children(
        self,
        flows_to: FlowsTo,
        id_to_node: Dict[str, PTreeNode],
        node_to_id: Dict[PTreeNode, str],
        ptree_depth: PTreeAndDepth,
    ) -> PTreeNode:
        ptree = ptree_depth["node"]
        node_id = node_to_id[ptree]
        children: List[PTreeNode] = []
        for child_id in flows_to[node_id]:
            if child_id in id_to_node:
                child = id_to_node[child_id]
                children.append(child)
            else:
                raise Exception(f"No child node found for ID: {child_id}")
        ptree.children = children
        return ptree

    def parse(self, provenance_data: Dict[str, RawPTreeNode]) -> PTreeNode:
        assert "1" in provenance_data, "No root node"
        id_to_node = {}
        node_to_id = {}
        ptree = self.parse_raw(provenance_data, id_to_node, node_to_id)
        flows_to = self.generate_flows_to(provenance_data)
        fn = cast(
            Callable[[PTreeAndDepth], None],
            partial(self.add_children, flows_to, id_to_node, node_to_id),
        )
        ptree.map(fn)
        return ptree


def main(args: List[str]):
    assert len(args) == 1, "Must provide a provenance tree path"
    provenance_path = Path(args[0])
    with open(provenance_path, "r") as prov_fp:
        provenance_data = json.load(prov_fp)
    ptree = PTreeParser().parse(provenance_data)
    print(ptree)
    print(ptree.serialize_children(verbose=True))


if __name__ == "__main__":
    main(argv[1:])

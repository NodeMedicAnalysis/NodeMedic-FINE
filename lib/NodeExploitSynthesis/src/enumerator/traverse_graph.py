import random
import subprocess
import traceback
from . import graph
from .graph import Root, TEMPL_GENERATING
from .template import Literal

DEBUG = False
def from_prefix_to_state(prefix, debug=DEBUG):
    ''' Traverse the graph from the root node to the node corresponding to the
    given prefix.
            Returns all states reachable after processing the prefix 
            
    '''

    prefix = prefix.split('\n')[-1]
    prefix = prefix.split('\t')[-1]
    prefix = prefix.split('\r')[-1]

    active_states = [([], Root([]))]

    for c in prefix:
        new_active_states = []
        seen = {}
        for context, state in active_states:
            next_states = state.next_states(context, c)
            for next_state, new_context in next_states:
                h = (hash(str(new_context)), next_state.__class__.__name__)
                if h not in seen:
                    new_active_states.append((new_context, next_state))
                    seen[h] = True

        if debug:
            print("Processed char", c, active_states, new_active_states)
        active_states = new_active_states
        
    return active_states

def from_prefix_to_completion(prefix):
    possible_states = from_prefix_to_state(prefix)

    for context, state in possible_states:
        try:
            completions = state.get_back_to_root(context)
            for completion in completions:
                yield prefix + completion
        except AssertionError as e:
            if DEBUG:
                print(e)

def finalize_template(template, should_trim=True):
    '''
        1. Remove trailing literals that are already included in inner prefixes

        2. Join Literal's together
    '''

    if len(template) == 1:
        return template
    
    if should_trim: # If complete started on a template-generating node, we should trim the first literal
            # TODO Test 3 +    where what comes after is an identifier
        #1.
        a = template[0]
        b = template[1]
        if len(b.value) != 0:
            a.value = a.value[:-len(b.value)]

    #2.
    final_template = []
    for el in template:
        if isinstance(el, Literal):
            if len(el.value) == 0:
                continue
            if len(final_template) == 0 or not isinstance(final_template[-1], Literal):
                final_template.append(el)
            else:
                final_template[-1].value += el.value
        else:
            final_template.append(el)

    return final_template


def different(template1, template2):
    '''
        Checks whether two templates are different
    '''
    if len(template1) != len(template2):
        return True

    for i in range(len(template1)):
        if template1[i].value != template2[i].value:
            return True
    return False

def from_prefix_to_template(prefix, max_states=-1, max_completions=-1):
    '''
        If max_states > 0, only consider the best max_states states that resulted from from_prefix_to_state
            Best = minimizes dist_to_root + len(context) to generate simpler payloads
        If max_completions > 0, only considr the first max_completions completions
    '''

    possible_states = from_prefix_to_state(prefix)
    possible_states = sorted(possible_states, key=lambda x: len(x[0]) + x[1].distance)
    if max_states > 0:
        possible_states = possible_states[:max_states]

    returned = []

    for context, state in possible_states:
        try: 
            completions = state.get_template(context)
            if max_completions > 0:
                completions = completions[:max_completions]

            for completion in completions:
                if all(different(completion, x) for x in returned):
                    yield finalize_template([Literal(prefix)] + completion, state.__class__.__name__ in TEMPL_GENERATING)
                    returned.append(completion)
        except AssertionError as e:
            return None

def random_walk(state, context):
    tran = random.choice(state.transitions)
    if len(tran) == 2:
        c, next_state = tran
        new_context = context
    else:
        c, next_state, new_context = tran
        if new_context is not None:
            new_context = context + [new_context]
        else:
            new_context = context[:-1] # Pop from context

    if next_state == state:
        new_state = state
    else:
        new_state = next_state(new_context)

    return new_state, new_context, c


# Tests soundness of Graph

def try_payload(payload):
    try:
        out = subprocess.check_output(['nodejs', '-e', f'eval(`{payload}`)'], stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        return b'SyntaxError' not in e.output or b"Unexpected token :" in e.output # Sometimes, objects are not parsed correctly by eval
    return True

def test_soundness(bound, freeze_on_size=100):
    total = 0
    success = 0
    while total < bound:
        total += 1

        context = []
        r = Root([])
        payload = ''
        traversed_states = []
        try:
            # Get out of Root
            while isinstance(r, Root):
                traversed_states.append(r)
                new_r, new_context, c  = random_walk(r, context)
                if c != '\\' and c != '`': # Lets not allow escape chars or the special quotes, to ease how to test payloads
                    r = new_r
                    context = new_context
                    payload += c

            # Get back to root
            done = 0
            while type(r) != Root:
                done += 1
                if done == freeze_on_size:
                    print('\nFroze:', r,'\n\n')
                    break
                traversed_states.append(r)
                new_r, new_context, c  = random_walk(r, context)
                if c != '\\' and c != '`': 
                    r = new_r
                    context = new_context
                    payload += c
            
            if done == freeze_on_size:
                total -= 1
                continue

            completions = r.get_back_to_root(context)
            payload += completions[0]
        except Exception as e:
            with open('crashed_payloads.txt','a+') as f:
                f.write(payload + '\n')

                stack_trace = traceback.format_exc()
                f.write(stack_trace + '\n')
                f.write(str(e) + '\n')
                f.write(str(traversed_states) + '\n')
            continue

        payload_san = payload.replace('\r','\\r')
        if not try_payload(payload):
            with open('failed_payloads.txt', 'a+') as f:
                f.write(payload_san + '\n')
                f.write(str(traversed_states) + '\n')
        else:
            success += 1

        #assert try_payload(payload), f'\n\neval("{payload_san}") threw a SyntaxError. States: {traversed_states}'
        print('Successfull walks:', success,'/', total,'=', round(success/total, 2)*100,'%', ' '*100, end='\r')

def test_completeness(dataset, num_templates=10):
    with open(f'../tests/enumerator/{dataset}') as f:
        data = f.read().split('\n')

    print('Running', len(data), ' tests...')

    for prefix in data:
        i = 0
        print('Generating templates for prefix: ' + repr(prefix))
        # Generate at most N templates for each prefix
        for template in from_prefix_to_completion(prefix):
            print('\t', template)
            if i > num_templates:
                break
            i += 1
        
        if i == 0:
            print('Tests failed')
            exit()

def verify_dist_property():
    node_distances = {}

    def find_distance(cls):
        for node in node_distances:
            if isinstance(node, cls):
                return node_distances[node]
        assert False

    # Test distance properties
    for el in dir(graph):
        if el != 'Node':
            a = eval(el)
            if 'next_states' in dir(a):
                assert 'distance' in dir(a)
                node_distances[a([])] = a.distance

    violations = []
    for node in node_distances:
        if isinstance(node, Root):
            continue

        min_distance = float('inf')
        min_distance_node = None

        for tran in node.transitions:
            assert len(tran) == 4, tran
            c = tran[0]
            next_node = tran[1]

            next_node_distance = find_distance(next_node)
            if next_node_distance < min_distance:
                min_distance = next_node_distance
                min_distance_node = next_node

        if node_distances[node] != min_distance + 1:
            violations.append((min_distance, min_distance_node, node))

    violations.sort(key=lambda x: x[0])
    for dist, next, node in violations:
        print(f"Distance property violated for {node} -> {next} (distance {dist})")

    assert len(violations) == 0
